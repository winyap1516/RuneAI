// 中文注释：统一静态导入 storageAdapter 及其扩展函数，避免动态导入导致模块重复打包
import storageAdapter, { saveWebsiteContent } from "/src/js/storage/storageAdapter.js";
import { normalizeUrl } from "/src/js/utils/url.js";
import { mockAIFromUrl as mockAIFromUrlExternal, mockFetchSiteContent as mockFetchSiteContentExternal } from "/src/mockFunctions.js";
import { migrateLocalToCloud } from "/src/js/sync/migrate.js";
import { syncLoop } from "/src/js/sync/syncAgent.js";
import { supabase } from "/src/js/services/supabaseClient.js";
import { config } from "/src/js/services/config.js";
import logger from "/src/js/services/logger.js";

// Cloud Configuration
const SUPABASE_URL = (import.meta?.env?.VITE_SUPABASE_URL || '').trim();
const SUPABASE_ANON_KEY = (import.meta?.env?.VITE_SUPABASE_ANON_KEY || '').trim();
// 中文注释：如果启用 Mock 模式，强制禁用云端同步，确保完全本地化
const useCloud = !config.useMock && Boolean(SUPABASE_URL && SUPABASE_ANON_KEY);

/**
 * Fetch link metadata from Cloud Edge Function
 * @param {string} url 
 * @returns {Promise<object>}
 */
async function fetchAIFromCloud(url) {
  // 中文注释：使用 Supabase SDK 调用 Edge Function（替代手动 fetch）
  if (!useCloud || !supabase) throw new Error('Cloud not configured');
  const { data, error } = await supabase.functions.invoke('super-endpoint', {
    body: { url },
  });
  if (error) throw error;
  return data;
}

/**
 * Load links from Cloud Supabase
 * @returns {Promise<Array>}
 */
async function loadCloudLinks() {
  // 中文注释：使用 Supabase SDK 拉取云端 links 列表，替代手动 fetch
  if (!useCloud || !supabase) return [];
  try {
    const { data, error } = await supabase
      .from('links')
      .select('*');
    if (error) throw error;
    const arr = Array.isArray(data) ? data : [];
    return arr.map(row => ({
      id: row.id,
      url: row.url || '',
      title: row.title || 'Untitled',
      description: row.description || 'Summary from cloud',
      category: row.category || 'All Links',
      tags: Array.isArray(row.tags) ? row.tags : [],
      created_at: row.created_at || Date.now(),
      updated_at: row.updated_at || Date.now(),
    }));
  } catch (e) {
    console.warn('[Supabase] loadCloudLinks failed:', e);
    return [];
  }
}

// =============================
// Link Controller Logic
// =============================

export const linkController = {
  _view: null,
  
  // Pagination State
  _pagination: {
    currentPage: 0,
    isLoading: false,
    hasMore: true
  },

  /**
   * Set the view for partial updates
   * @param {object} view 
   */
  setView(view) {
    this._view = view;
  },

  /**
   * Get all links with subscription status
   * @returns {Promise<Array>} Links array with 'subscribed' boolean
   */
  async getLinks() {
    // 1. Read Links
    let links = await storageAdapter.getLinks();
    
    // Check empty / cloud logic
    if (links.length === 0 && useCloud) {
       const cloudLinks = await loadCloudLinks();
       if (cloudLinks.length > 0) {
          // Sync cloud links to local
          for (const c of cloudLinks) {
             const exists = links.find(l => normalizeUrl(l.url) === normalizeUrl(c.url));
             if (!exists) {
               await storageAdapter.addLink(c);
             }
             storageAdapter.ensureCategory(c.category);
          }
          // Refetch to get IDs generated by adapter if any (though adapter usually returns object)
          links = await storageAdapter.getLinks();
       } else {
         // No cloud links, inject samples if truly empty
         // This logic was in dashboard.js "injectSamples".
         // We'll expose injectSamples as a separate method or handle it here?
         // The dashboard logic was: if empty -> try cloud -> if cloud empty -> inject samples.
         // We will return empty list here and let dashboard decide to inject samples?
         // Or we provide an "initializeDefaults" method.
       }
    }

    // 2. Read Subscriptions
    const subs = await storageAdapter.getSubscriptions();
    
    // 3. Merge Subscription Status
    const subMap = new Map(subs.filter(s => s.enabled !== false).map(s => [String(s.linkId), s.id]));
    
    return links.map(link => ({
        ...link,
        subscribed: subMap.has(String(link.id)),
        subscriptionId: subMap.get(String(link.id)) || null
    }));
  },

  /**
   * Subscribe to a link
   * @param {number|string} linkId 
   */
  async subscribe(linkId) {
    const silent = !!this._view;
    const sub = await storageAdapter.subscribeToLink(linkId, { silent });
    if (this._view) {
        this._view.updateSingleCardUI(linkId, { subscribed: true, subscriptionId: sub.id });
    }
    return sub;
  },

  /**
   * Unsubscribe from a link
   * @param {number|string} subId 
   */
  async unsubscribe(subId) {
    // storageAdapter might not have unsubscribeById, it has deleteSubscription(id) or similar?
    // storageAdapter has `updateSubscription` (enable/disable) or delete.
    // Usually we toggle `enabled`.
    // Let's check storageAdapter.
    const subs = await storageAdapter.getSubscriptions();
    const sub = subs.find(s => String(s.id) === String(subId));
    if (sub) {
        sub.enabled = false; // Soft delete/disable
        const silent = !!this._view;
        await storageAdapter.updateSubscription(sub, { silent });
        if (this._view) {
             this._view.updateSingleCardUI(sub.linkId, { subscribed: false });
        }
    }
  },

  /**
   * Fetch paginated links
   * @param {number} pageIndex 0-based index
   * @param {number} pageSize 
   * @returns {Promise<object>} { items, total, hasMore }
   */
  async fetchPage(pageIndex = 0, pageSize = 20) {
    // Sync state if page 0 is requested (reset)
    if (pageIndex === 0) {
        this._pagination.currentPage = 0;
        this._pagination.hasMore = true;
        this._pagination.isLoading = false;
    }

    const offset = pageIndex * pageSize;
    return await storageAdapter.getLinksPage({ limit: pageSize, offset });
  },

  async loadNextPage() {
    if (this._pagination.isLoading || !this._pagination.hasMore) return;
    
    this._pagination.isLoading = true;
    try {
        const nextPage = this._pagination.currentPage + 1;
        const { items, total, hasMore } = await this.fetchPage(nextPage, 20);
        
        // Update state
        this._pagination.currentPage = nextPage;
        this._pagination.hasMore = hasMore;
        
        // Append to view
        if (items.length > 0 && this._view) {
            this._view.appendPage(items);
        }
    } catch (err) {
        console.error('Failed to load next page:', err);
    } finally {
        this._pagination.isLoading = false;
    }
  },

  /**
   * Get all subscriptions (for UI updates)
   * @returns {Promise<Array>}
   */
  async getSubscriptions() {
    return await storageAdapter.getSubscriptions();
  },

  /**
   * Find a link by URL
   * @param {string} url 
   * @returns {Promise<object|null>}
   */
  async findLinkByUrl(url) {
    const target = String(url).trim();
    if (!target) return null;
    const links = await storageAdapter.getLinks();
    return links.find(c => String(c.url).trim() === target) || null;
  },

  /**
   * Add a new link
   * @param {string} rawUrl 
   * @returns {Promise<object>} The created link object
   */
  async addLink(rawUrl) {
    const normalized = normalizeUrl(rawUrl);
    if (!normalized) throw new Error('Invalid URL');

    // Check duplicate
    const exists = await this.findLinkByUrl(normalized);
    if (exists) throw new Error('Link already exists');

    // 中文注释：本地新增链接不再调用 Mock/Cloud 摘要
    // 仅根据 URL 提取基础元信息；摘要由用户点击 “Generate Now” 或 Digest 页面手动生成
    const parsed = { title: normalized.replace(/^https?:\/\//, '').split('/')[0] };

    const data = {
      title: parsed?.title || (normalized.replace(/^https?:\/\//, '').split('/')[0] || 'Untitled'),
      description: parsed?.description || 'AI summary placeholder… 点击 Generate Now 开始生成',
      category: parsed?.category || 'All Links',
      tags: Array.isArray(parsed?.tags) && parsed.tags.length ? parsed.tags : ['bookmark'],
      url: normalized,
    };

    // 中文注释：为兼容单元测试与视图局部刷新策略：
    // - 若存在视图（this._view 非空），则以 silent=true 写入存储并手动调用视图的 addSingleCardUI 进行增量插入；
    // - 若无视图，则让存储触发全量通知（silent=false），由外层渲染器统一刷新。
    const silent = !!this._view;
    const added = await storageAdapter.addLink(data, { silent });
    // 长文本内容存入分表（mock 抓取），UI 优先渲染 summary
    try {
      const siteResp = await mockFetchSiteContentExternal(normalized).catch(() => ({ data: null }));
      const siteData = (siteResp && 'data' in siteResp) ? (siteResp.data || {}) : siteResp;
      if (siteData && siteData.content) {
        const summaryText = data.description || siteData.content.slice(0, 300);
        // 中文注释：延迟调用已静态导入的 saveWebsiteContent，避免阻塞 UI 且消除动态导入重复模块问题
        Promise.resolve().then(() => {
          return saveWebsiteContent(added.id, { content: siteData.content, summary: summaryText })
        }).catch(() => {});
      }
    } catch {}
    if (this._view) {
      // 中文注释：视图存在时，执行局部 UI 插入，避免全量 re-render
      try { this._view.addSingleCardUI(added); } catch (e) { /* no-op */ }
    }
    return added;
  },

  /**
   * Update an existing link
   * @param {number|string} id 
   * @param {object} updates { title, url, description, tags, category }
   * @returns {Promise<object>} Updated link object
   */
  async updateLink(id, updates) {
    const { title, url, description, tags, category } = updates;
    
    // Check URL conflict if URL changed
    if (url) {
        const normalized = normalizeUrl(url);
        const allLinks = await storageAdapter.getLinks();
        const conflict = allLinks.find(c => String(c.id) !== String(id) && normalizeUrl(c.url) === normalized);
        if (conflict) {
            throw new Error(`URL conflict: "${conflict.title}" already uses this URL.`);
        }
    }

    const silent = !!this._view;
    await storageAdapter.updateLink(id, { title, url, description, tags, category }, { silent });
    logger.info(`[LinkController] Link updated: ${id}`, { tags });

    // 中文注释：使用 Supabase SDK 更新云端数据（替代 Edge Function）
    if (useCloud && supabase && url) {
        try {
            const updates = { title, description, category, tags };
            const { error } = await supabase
              .from('links')
              .update(updates)
              .eq('url', url);
            if (error) throw error;
        } catch (err) {
            console.error('[Supabase] update link failed:', err);
        }
    }

    const updated = (await storageAdapter.getLinks()).find(c => String(c.id) === String(id));
    if (!updated) throw new Error('Link not found after update');
    
    if (this._view) {
        this._view.updateSingleCardUI(id, updated);
    }

    return updated;
  },

  /**
   * Delete a link
   * @param {number|string} id 
   */
  async deleteLink(id) {
    const links = await storageAdapter.getLinks();
    const data = links.find(c => String(c.id) === String(id));
    
    const silent = !!this._view;
    await storageAdapter.deleteLink(id, { silent });

    if (this._view) {
        this._view.removeSingleCardUI(id);
    }

    // 中文注释：使用 Supabase SDK 删除云端数据（替代 Edge Function）
    if (useCloud && supabase && data?.url) {
        try {
            const { error } = await supabase
              .from('links')
              .delete()
              .eq('url', data.url);
            if (error) throw error;
        } catch (err) {
            console.error('[Supabase] delete link failed:', err);
        }
    }
  },

  /**
   * Initialize with sample data
   */
  async injectSamples() {
      const samples = [
        {
          title: 'Figma — Design tool',
          description: 'AI Summary: Figma is a modern design collaboration platform for prototyping and UI design.',
          category: 'Design',
          tags: ['Design', 'Productivity'],
          url: 'https://figma.com/',
        },
        {
          title: 'OpenAI — GPT Models',
          description: 'AI Summary: OpenAI provides advanced large language models and API access.',
          category: 'AI',
          tags: ['AI', 'Research'],
          url: 'https://openai.com/',
        },
        {
          title: 'GitHub — Code hosting',
          description: 'AI Summary: GitHub is a mainstream code hosting and collaboration platform.',
          category: 'Development',
          tags: ['Development'],
          url: 'https://github.com/',
        },
      ];
      for (const data of samples) {
          await storageAdapter.addLink(data);
      }
  },

  // Category Management
  getCategories() {
      return storageAdapter.getCategories();
  },

  ensureCategory(name) {
      return storageAdapter.ensureCategory(name);
  },

  async deleteCategory(name) {
      storageAdapter.deleteCategory(name);
      // Update links
      const links = await storageAdapter.getLinks();
      let changed = false;
      links.forEach(l => {
        if (l.category === name) {
            l.category = 'All Links';
            changed = true;
        }
      });
      if (changed) storageAdapter.saveLinks(links);
  },

  /**
   * 将现有链接随机分配到分类（开发辅助）
   * - 若当前仅存在 'All Links'，会自动创建一组默认分类
   * - 排除保留分类 'All Links'
   * @param {Array<string>} pool 自定义分类池（可选）
   * @returns {Promise<number>} 实际更新的链接数量
   */
  async distributeToCategories(pool = []) {
    const isDev = import.meta?.env?.DEV;
    if (!isDev) return 0; // 中文注释：仅开发环境允许批量分配

    // 中文注释：读取现有分类；若不足，则创建默认分类集
    let cats = Array.isArray(pool) && pool.length ? pool.slice() : (await storageAdapter.getCategories());
    const RESERVED = new Set(['All Links']);
    if (!cats || cats.filter(c => !RESERVED.has(c)).length === 0) {
      cats = ['AI','Design','News','Dev','Tools','Product','Blog','Research','Docs'];
      for (const c of cats) { try { await storageAdapter.ensureCategory(c); } catch {} }
    }
    const choices = cats.filter(c => !RESERVED.has(c));
    if (choices.length === 0) return 0;

    // 中文注释：读取所有链接并随机分配分类；为减少通知风暴，使用 silent 写入并在视图存在时局部刷新
    const links = await storageAdapter.getLinks();
    const silent = !!this._view;
    let updated = 0;

    const pick = () => choices[Math.floor(Math.random() * choices.length)];
    for (const l of links) {
      const target = pick();
      if (!target || l.category === target) continue;
      await storageAdapter.updateLink(l.id, { category: target }, { silent });
      if (this._view) {
        try { this._view.updateSingleCardUI(l.id, { category: target }); } catch {}
      }
      updated++;
    }

    // 中文注释：更新侧栏（视图存在时会在 updateSingleCardUI 内自动刷新；此处兜底）
    try { await storageAdapter.notify({ type: 'links_changed' }); } catch {}

    return updated;
  },

  /**
   * 批量生成随机链接（仅开发模式）
   * @param {number} count 生成数量，默认 200
   * @returns {Promise<number>} 实际生成数量
   */
  async seedRandomLinks(count = 200) {
    // 中文注释：仅在开发模式允许批量生成，避免污染生产数据
    const isDev = import.meta?.env?.DEV;
    if (!isDev) return 0;
    const safeCount = Math.max(1, Math.min(1000, Number(count) || 200));

    // 中文注释：准备随机词库与辅助函数
    const words = ['alpha','beta','gamma','delta','omega','nova','pixel','orbit','quantum','rune','matrix','vector','flux','zen','nimbus','spark'];
    const pick = () => words[Math.floor(Math.random() * words.length)];
    const rand = (n=999999) => Math.floor(Math.random() * n) + 1;

    // 中文注释：静默写入以提升性能（视图存在时走局部插入）
    const silent = !!this._view;
    let created = 0;

    for (let i = 0; i < safeCount; i++) {
      const dn = `${pick()}-${rand(9999)}`;
      const path = `${pick()}/${rand(999)}`;
      const url = `https://www.${dn}.example.com/${path}`;

      // 中文注释：去重检查（避免重复 URL 导致报错）
      const exists = await this.findLinkByUrl(url);
      if (exists) continue;

      const data = {
        title: `Random Site ${i + 1} · ${pick()}`,
        description: '随机占位描述（开发数据），可用于分页与筛选性能测试。',
        category: 'All Links',
        tags: ['bookmark','random'],
        url
      };

      const added = await storageAdapter.addLink(data, { silent });
      // 中文注释：若视图存在，执行局部 UI 插入以避免全量重渲染
      if (this._view) {
        try { this._view.addSingleCardUI(added); } catch(e) {}
      }
      created++;
    }

    // 中文注释：确保分类侧栏包含 All Links（通常默认存在）
    try { storageAdapter.ensureCategory('All Links'); } catch {}

    return created;
  },

  /**
   * 登录后初始化同步与迁移（可由外部在登录成功后调用）
   */
  async initSyncAfterLogin() {
    try {
      await migrateLocalToCloud();
      syncLoop();
    } catch (e) {
      console.warn('[InitSync] failed', e);
    }
  }
};
