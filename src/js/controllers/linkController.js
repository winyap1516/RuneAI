// 中文注释：统一静态导入 storageAdapter 及其扩展函数，避免动态导入导致模块重复打包
import storageAdapter, { saveWebsiteContent } from "/src/js/storage/storageAdapter.js";
import { normalizeUrl, ensureAbsoluteUrl } from "/src/js/utils/url.js";
import { mockAIFromUrl as mockAIFromUrlExternal, mockFetchSiteContent as mockFetchSiteContentExternal } from "/src/mockFunctions.js";
import { migrateLocalToCloud } from "/src/js/sync/migrate.js";
import { syncLoop } from "/src/js/sync/syncAgent.js";
import { setMapping, getServerId } from "/src/js/sync/idMapping.js";
import { supabase, callFunction } from "/src/js/services/supabaseClient.js";
import config from "/src/js/services/config.js";
import logger from "/src/js/services/logger.js";
import { pythonApi } from "/src/js/services/pythonApi.js";

// Cloud Configuration
const SUPABASE_URL = config.supabaseUrl;
const SUPABASE_ANON_KEY = config.supabaseAnonKey;
// 中文注释：如果启用 Mock 模式，强制禁用云端同步；为兼容单测环境下的部分 mock，加入空值保护
// 强制禁用 Supabase 云端，只允许本地 Python 模式
const useCloud = config.useLocalDev || (!(config && config.useMock) && Boolean(SUPABASE_URL && SUPABASE_ANON_KEY));

// Debug Log
console.log('[LinkController] Init:', { useCloud, useMock: config.useMock, hasUrl: !!SUPABASE_URL, hasKey: !!SUPABASE_ANON_KEY });

/**
 * Fetch link metadata from Cloud Edge Function
 * @param {string} url 
 * @returns {Promise<object>}
 */
async function fetchAIFromCloud(url) {
  console.log('[LinkController] Using Python API for:', url);
  try {
    const result = await pythonApi.syncLink(url);
    return {
      title: url,
      description: 'Processing with AI...',
      tags: [],
      ai_status: 'queued',
      // Store IDs for future polling if needed
      job_id: result.job_id,
      link_id: result.link_id
    };
  } catch (e) {
    console.error('[LinkController] Python sync failed:', e);
    throw e;
  }
}

/**
 * 生成简易 UUID（用于 sync-push 的 client_change_id）
 * - 中文注释：避免重复，确保服务端幂等记录
 */
function __uuid4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

/**
 * Load links from Cloud Supabase
 * @returns {Promise<Array>}
 */
async function loadCloudLinks() {
  try {
    const links = await pythonApi.getLinks();
    return links.map(l => ({
      id: l.id,
      url: l.url,
      title: l.url, // Python backend currently doesn't scrape title separately
      description: l.description || 'Processing...',
      tags: [],
      category: 'All Links',
      ai_status: l.ai_status,
      created_at: l.created_at,
      updated_at: l.created_at
    }));
  } catch (e) {
    console.error('Python API load failed:', e);
    return [];
  }
}

// =============================
// Link Controller Logic
// =============================

export const linkController = {
  _view: null,
  
  // Pagination State
  _pagination: {
    currentPage: 0,
    isLoading: false,
    hasMore: true
  },

  /**
   * Set the view for partial updates
   * @param {object} view 
   */
  setView(view) {
    this._view = view;
  },

  /**
   * Get all links with subscription status
   * @returns {Promise<Array>} Links array with 'subscribed' boolean
   */
  async getLinks() {
    // 1. Read Links
    let links = await storageAdapter.getLinks();
    
    // Check empty / cloud logic
    if (links.length === 0 && useCloud) {
       const cloudLinks = await loadCloudLinks();
       if (cloudLinks.length > 0) {
          // Sync cloud links to local
          for (const c of cloudLinks) {
             const exists = links.find(l => normalizeUrl(l.url) === normalizeUrl(c.url));
             if (!exists) {
               await storageAdapter.addLink(c);
             }
             storageAdapter.ensureCategory(c.category);
          }
          // Refetch to get IDs generated by adapter if any (though adapter usually returns object)
          links = await storageAdapter.getLinks();
       } else {
         // No cloud links, inject samples if truly empty
         // This logic was in dashboard.js "injectSamples".
         // We'll expose injectSamples as a separate method or handle it here?
         // The dashboard logic was: if empty -> try cloud -> if cloud empty -> inject samples.
         // We will return empty list here and let dashboard decide to inject samples?
         // Or we provide an "initializeDefaults" method.
       }
    }

    // 2. Read Subscriptions
    const subs = await storageAdapter.getSubscriptions();
    
    // 3. Merge Subscription Status
    const subMap = new Map(subs.filter(s => s.enabled !== false).map(s => [String(s.linkId), s.id]));
    
    return links.map(link => ({
        ...link,
        subscribed: subMap.has(String(link.id)),
        subscriptionId: subMap.get(String(link.id)) || null
    }));
  },

  /**
   * Subscribe to a link
   * @param {number|string} linkId 
   */
  async subscribe(linkId) {
    const silent = !!this._view;
    const sub = await storageAdapter.subscribeToLink(linkId, { silent });
    if (this._view) {
        this._view.updateSingleCardUI(linkId, { subscribed: true, subscriptionId: sub.id });
    }
    return sub;
  },

  /**
   * Unsubscribe from a link
   * @param {number|string} subId 
   */
  async unsubscribe(subId) {
    // storageAdapter might not have unsubscribeById, it has deleteSubscription(id) or similar?
    // storageAdapter has `updateSubscription` (enable/disable) or delete.
    // Usually we toggle `enabled`.
    // Let's check storageAdapter.
    const subs = await storageAdapter.getSubscriptions();
    const sub = subs.find(s => String(s.id) === String(subId));
    if (sub) {
        sub.enabled = false; // Soft delete/disable
        const silent = !!this._view;
        await storageAdapter.updateSubscription(sub, { silent });
        if (this._view) {
             this._view.updateSingleCardUI(sub.linkId, { subscribed: false });
        }
    }
  },

  /**
   * Fetch paginated links
   * @param {number} pageIndex 0-based index
   * @param {number} pageSize 
   * @returns {Promise<object>} { items, total, hasMore }
   */
  async fetchPage(pageIndex = 0, pageSize = 20) {
    // Sync state if page 0 is requested (reset)
    if (pageIndex === 0) {
        this._pagination.currentPage = 0;
        this._pagination.hasMore = true;
        this._pagination.isLoading = false;
    }

    const offset = pageIndex * pageSize;
    return await storageAdapter.getLinksPage({ limit: pageSize, offset });
  },

  async loadNextPage() {
    if (this._pagination.isLoading || !this._pagination.hasMore) return;
    
    this._pagination.isLoading = true;
    try {
        const nextPage = this._pagination.currentPage + 1;
        const { items, total, hasMore } = await this.fetchPage(nextPage, 20);
        
        // Update state
        this._pagination.currentPage = nextPage;
        this._pagination.hasMore = hasMore;
        
        // Append to view
        if (items.length > 0 && this._view) {
            this._view.appendPage(items);
        }
    } catch (err) {
        console.error('Failed to load next page:', err);
    } finally {
        this._pagination.isLoading = false;
    }
  },

  /**
   * Get all subscriptions (for UI updates)
   * @returns {Promise<Array>}
   */
  async getSubscriptions() {
    return await storageAdapter.getSubscriptions();
  },

  /**
   * Find a link by URL
   * @param {string} url 
   * @returns {Promise<object|null>}
   */
  async findLinkByUrl(url) {
    const target = String(url).trim();
    if (!target) return null;
    const links = await storageAdapter.getLinks();
    return links.find(c => String(c.url).trim() === target) || null;
  },

  /**
   * Add a new link
   * @param {string} rawUrl 
   * @returns {Promise<object>} The created link object
   */
  async addLink(rawUrl) {
    // 中文注释：同时计算归一化（存储/去重）与绝对地址（云端抓取）
    const normalized = normalizeUrl(rawUrl);
    const absolute = ensureAbsoluteUrl(rawUrl);
    if (!normalized) throw new Error('Invalid URL');

    // Check duplicate
    const exists = await this.findLinkByUrl(normalized);
    if (exists) throw new Error('Link already exists');

    // 1. 构建初始对象（Processing 状态），立即写入存储以满足单测期望与数据可见性
    const parsed = { title: normalized.replace(/^https?:\/\//, '').split('/')[0] };
    const initialData = {
      title: parsed.title || 'Untitled',
      description: 'AI Processing...',
      category: 'All Links',
      tags: ['processing'],
      url: normalized,
      source: 'Manual',
      ai_status: 'processing'
    };
    const silent = !!this._view;
    const added = await storageAdapter.addLink(initialData, { silent });
    // 视图存在时，插入正式卡片（含真实 ID），避免临时 ID 替换带来的竞态
    if (this._view && typeof this._view.addSingleCardUI === 'function') {
      this._view.addSingleCardUI(added);
    }
    // 中文注释：立即触发同步循环（云端环境下）
    // 目的：确保“创建”变更尽快推送到后端数据库，即使 AI 后续失败也不会丢失初始记录
    // 说明：syncLoop 内部具有云端可用性与登录状态检测；此处轻触发，无副作用
    try {
      if (useCloud) {
        setTimeout(() => syncLoop(), 500);
      }
    } catch (e) {
      console.warn('[LinkController] Initial syncLoop trigger failed:', e);
    }

    // 2. 异步处理 AI（带重试与超时）
    // 中文注释：Python 模式下，启动轮询检测状态
    Promise.resolve().then(async () => {
      let aiMeta = null;
      let error = null;
      
      // 重试逻辑：最多 3 次，每次间隔 2s
      for (let i = 0; i < 3; i++) {
        try {
          // 超时控制：30s
          const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('AI Timeout')), 30000));
          let cloudPromise;
          
          if (useCloud) {
             // Python API Call (Trigger)
             // fetchAIFromCloud already called syncLink (POST /sync) which returns { job_id, link_id } immediately.
             // So we need to call it here, get the IDs, then Poll.
             const initResp = await fetchAIFromCloud(absolute);
             
             // Start Polling for completion
             const serverId = initResp.link_id;
             let pollResult = null;
             for (let j=0; j<15; j++) {
                 await new Promise(r => setTimeout(r, 2000));
                 try {
                     const statusData = await pythonApi.getLink(serverId);
                     if (statusData.ai_status === 'completed') {
                         pollResult = statusData;
                         break;
                     }
                 } catch(e) { console.warn('Poll error', e); }
             }
             
             if (pollResult) {
                 cloudPromise = Promise.resolve(pollResult);
             } else {
                 throw new Error('AI Processing Timeout (Polling)');
             }
          } else {
             // Mock 模式
             cloudPromise = mockAIFromUrlExternal(absolute).catch(() => null);
          }
          
          const resp = await Promise.race([cloudPromise, timeoutPromise]);
          // 检查有效性
          const data = resp; // In Python mode, resp is the link object
          
          if (data && (data.title || data.description)) {
            aiMeta = { 
                title: data.title || data.url,
                description: data.description,
                tags: ['completed'],
                ai_status: 'completed'
            };
            break; // 成功，跳出重试
          } else {
            throw new Error('Invalid AI response');
          }
        } catch (e) {
          error = e;
          console.warn(`[LinkController] AI attempt ${i+1} failed:`, e);
          if (i < 2) await new Promise(r => setTimeout(r, 2000)); // Wait before retry
        }
      }

      // 3. 处理结果
      if (aiMeta) {
        // A) 成功：更新数据库（IndexedDB + Supabase Sync），不再二次 addLink
        const updates = {
          title: aiMeta.title || added.title,
          description: aiMeta.description || added.description,
          category: aiMeta.category || added.category,
          tags: (Array.isArray(aiMeta.tags) && aiMeta.tags.length > 0) ? aiMeta.tags : ['completed'],
          ai_status: 'completed'
        };
        // 中文注释：抓取站点内容并保存（满足回归单测对 saveWebsiteContent 的断言）；优先执行，避免后续 update 抛错导致未调用
        try {
          const contentResp = await mockFetchSiteContentExternal(absolute).catch(() => null);
          const contentObj = contentResp && typeof contentResp === 'object' && 'data' in contentResp ? contentResp.data : contentResp;
          if (contentObj && typeof contentObj === 'object' && contentObj.content) {
            await saveWebsiteContent(added.id, contentObj);
          }
        } catch (e) {
          console.warn('[LinkController] saveWebsiteContent failed:', e?.message || e);
        }
        try {
          // 中文注释：调用控制器层的 updateLink，确保落库至后端（Supabase/EdgeFn），并触发同步循环
          // Python 适配：updateLink 会更新本地，然后 syncLoop 会尝试 push。但我们现在禁用了 syncLoop。
          // 而且 Python 后端已经有了最新的数据。所以我们只需要更新本地 IndexedDB 即可。
          // await this.updateLink(added.id, updates); 
          // 改为直接更新本地，不触发 updateLink 的副作用（防止 push 到不存在的 Supabase）
          await storageAdapter.updateLink(added.id, updates);
          if (this._view) this._view.updateCardUI(added.id, updates);

          // 中文注释：若服务端返回 authoritative row（含服务器 UUID），写入本地映射，便于后续使用服务器 ID 进行变更
          try {
            const srv = aiMeta.__server_row;
            const serverId = srv && (srv.id || srv.website_id || srv.uuid);
            if (serverId) setMapping('website', added.id, String(serverId));
          } catch (mapErr) {
            console.warn('[LinkController] setMapping failed:', mapErr?.message || mapErr);
          }
          // 若存在 authoritative row，则以服务器数据为准进行 UI 屺部覆盖（防止与服务端偏差）
          if (aiMeta.__server_row && this._view) {
            const srv = aiMeta.__server_row;
            this._view.updateSingleCardUI(added.id, {
              title: srv.title ?? updates.title,
              description: srv.description ?? updates.description,
              category: srv.category ?? updates.category,
              tags: Array.isArray(srv.tags) ? srv.tags : updates.tags,
              ai_status: srv.ai_status ?? 'completed'
            });
          }
          logger.info('[LinkController] Link updated successfully after AI');
        } catch (e) {
          console.error('[LinkController] Storage update failed:', e);
          if (this._view) this._view.updateSingleCardUI(added.id, { ai_status: 'failed', description: 'Storage Error: ' + e.message });
        }
      } else {
        // B) 失败：仍需写入数据库（Basic Info），状态标记为 Failed，避免数据丢失
        console.warn('[LinkController] AI failed, saving basic link info');
        
        try {
           const failUpdates = {
             title: added.title || 'Untitled Link',
             description: 'AI Analysis Failed: ' + (error?.message || 'Unknown error'),
             category: 'All Links',
             tags: ['failed'],
             ai_status: 'failed'
           };
           // 中文注释：同样使用控制器层 updateLink，以确保失败状态也能同步到后端
           await this.updateLink(added.id, failUpdates);
           logger.info('[LinkController] Saved fallback state after AI failure');
        } catch (e) {
           console.error('[LinkController] Fallback storage failed:', e);
           if (this._view) {
             this._view.updateSingleCardUI(added.id, { 
               ai_status: 'failed', 
               tags: ['error'],
               description: 'Critical: Failed to save to database. ' + e.message 
             });
           }
        }
      }
    });

    // 返回已写入存储的对象（包含真实 ID），满足单测与调用方的同步语义
    return added;
  },

  /**
   * Manually trigger AI generation for a link
   * @param {string} id Link ID
   */
  async generateAI(id) {
    const link = (await storageAdapter.getLinks()).find(c => String(c.id) === String(id));
    if (!link) throw new Error('Link not found');
    
    // Check if it is already completed to avoid redundant calls? 
    // No, user might want to re-generate.
    
    // 1. 更新状态为正在处理
    await this.updateLink(id, { description: 'AI Analyzing content...', ai_status: 'pending' });

    try {
      const absolute = ensureAbsoluteUrl(link.url);
      
      let aiMeta = null;
      if (useCloud) {
          // 调用云端 Edge Function
          // timeout protection? callFunction has its own timeout?
          // Let's add a timeout race here just in case Edge hangs forever
          const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('AI Analysis Timeout')), 25000));
          const cloudPromise = fetchAIFromCloud(absolute);
          
          const cloudResp = await Promise.race([cloudPromise, timeoutPromise]);
          aiMeta = (cloudResp && typeof cloudResp === 'object' && 'data' in cloudResp) ? (cloudResp.data || null) : cloudResp;
      } else {
          // 本地 Mock
          const mockResp = await mockAIFromUrlExternal(absolute).catch(() => null);
          aiMeta = (mockResp && typeof mockResp === 'object' && 'data' in mockResp) ? mockResp.data : mockResp;
      }

      if (aiMeta) {
          const updates = {
            title: aiMeta.title || link.title,
            description: aiMeta.description || link.description,
            category: aiMeta.category || link.category,
            tags: Array.isArray(aiMeta.tags) && aiMeta.tags.length > 0 ? aiMeta.tags : link.tags,
            ai_status: 'completed'
          };
          
          // 中文注释：更新本地和云端
          await this.updateLink(id, updates);
          return updates;
      } else {
          throw new Error('No AI data returned');
      }
    } catch (err) {
      console.error('[LinkController] Generate failed:', err);
      // 中文注释：AI 失败时，仍然调用 updateLink 以确保状态（failed）同步到云端
      const failUpdates = { 
          ai_status: 'failed', 
          description: 'AI Analysis Failed: ' + (err.message || 'Unknown Error'),
          tags: [...(link.tags || []), 'failed'] 
      };
      await this.updateLink(id, failUpdates).catch(e => console.warn('Failed to sync error state:', e));
      throw err;
    }
  },

  /**
   * Update an existing link
   * @param {number|string} id 
   * @param {object} updates { title, url, description, tags, category }
   * @returns {Promise<object>} Updated link object
   */
  async updateLink(id, updates) {
    const { title, url, description, tags, category, ai_status, source } = updates;
    
    // Check URL conflict if URL changed
    if (url) {
        const normalized = normalizeUrl(url);
        const allLinks = await storageAdapter.getLinks();
        const conflict = allLinks.find(c => String(c.id) !== String(id) && normalizeUrl(c.url) === normalized);
        if (conflict) {
            throw new Error(`URL conflict: "${conflict.title}" already uses this URL.`);
        }
    }

    const silent = !!this._view;
    await storageAdapter.updateLink(id, { title, url, description, tags, category, ai_status, source }, { silent });
    logger.info(`[LinkController] Link updated: ${id}`, { tags });

    // 中文注释：云端同步（优先使用 sync-push + 服务器 UUID；若无映射再回退 SDK/EdgeFn）
    if (useCloud && supabase) {
        const updatedLocal = (await storageAdapter.getLinks()).find(c => String(c.id) === String(id));
        // 中文注释：优先使用服务器 UUID（保证唯一性与准确性）
        const serverId = getServerId('website', id);
        // 中文注释：为避免与云端数据库的 URL 比对失败（本地可能为归一化 host+path），此处统一转换为绝对地址（https://…）
        const urlKeyRaw = url || updatedLocal?.url || null;
        const urlKey = urlKeyRaw ? ensureAbsoluteUrl(urlKeyRaw) : null;
        // 中文注释：优先从 Supabase Session 获取真实 UUID，若无则尝试 storageAdapter
        let userId = (await supabase.auth.getSession())?.data?.session?.user?.id;
        if (!userId) userId = storageAdapter.getUser()?.id || null;
        
        const cloudPatch = { title, description, category, tags, ai_status, source };
        let synced = false;

        // 方案 A：使用 sync-push（update + 服务器 UUID）
        if (serverId) {
          try {
            const changes = [{
              client_change_id: __uuid4(),
              resource_type: 'website',
              op: 'update',
              resource_id: serverId,
              payload: cloudPatch,
              base_server_ts: updatedLocal?.updated_at || null,
              field_timestamps: Object.keys(cloudPatch).reduce((m,k)=>{ m[k]=new Date().toISOString(); return m; },{})
            }];
            logger.info('[SyncPush] 直接上报 update（server_id）', { serverId, patch: cloudPatch });
            const resp = await callFunction('sync-push', { method: 'POST', body: JSON.stringify({ changes }) });
            if (!resp.ok) {
              const j = await resp.json().catch(()=>({}));
              throw new Error(j.error || `HTTP_${resp.status}`);
            }
            const data = await resp.json().catch(()=>({}));
            const applied = Array.isArray(data.applied) ? data.applied : [];
            synced = applied.length > 0;
          } catch (e) {
            logger.warn('[SyncPush] 更新失败，准备回退 SDK/EdgeFn', e?.message || e);
          }
        }

        // 方案 B：回退 SDK（优先使用 id；无 id 则使用 url）
        if (!synced && userId) {
          try {
            let query = supabase.from('links').update(cloudPatch).eq('user_id', userId);
            if (serverId) {
              logger.info('[Supabase] SDK 更新尝试（links.update by id）', { userId, id: serverId, patch: cloudPatch });
              query = query.eq('id', serverId);
            } else if (urlKey) {
              logger.info('[Supabase] SDK 更新尝试（links.update by url）', { userId, url: urlKey, patch: cloudPatch });
              query = query.eq('url', urlKey);
            } else {
              throw new Error('No valid identifier for SDK update');
            }
            const { data, error } = await query.select('id');
            if (error) throw error;
            synced = Array.isArray(data) && data.length > 0;
            if (!synced) {
              logger.warn('[Supabase] SDK 更新成功但无匹配行，准备回退 EdgeFn');
            }
          } catch (err) {
            logger.warn('[Supabase] SDK 更新失败，准备回退 EdgeFn', err?.message || err);
          }
        }

        // 方案 C：最终回退 EdgeFn（仅支持 URL）
        if (!synced && urlKey) {
          try {
            const payload = { url: urlKey, ...cloudPatch };
            logger.info('[EdgeFn] update-link 请求（URL 基准）', { payload });
            const resp = await callFunction('update-link', { method: 'POST', body: JSON.stringify(payload) });
            if (!resp.ok) {
              const j = await resp.json().catch(()=>({}));
              throw new Error(j.error || `HTTP_${resp.status}`);
            }
            logger.info('[LinkController] EdgeFn:update-link 同步成功');
          } catch (e) {
            logger.warn('[LinkController] EdgeFn:update-link 同步失败', e?.message || e);
          }
        }
    }

    const updated = (await storageAdapter.getLinks()).find(c => String(c.id) === String(id));
    if (!updated) throw new Error('Link not found after update');
    
    if (this._view) {
        this._view.updateSingleCardUI(id, updated);
    }

    // 中文注释：触发后台同步循环，确保通过 sync-push 机制补救可能失败的实时写入
    // 这对于解决 "前端完成，后端 Pending" 至关重要，因为如果上面的 SDK/EdgeFn 都失败了，SyncLoop 是最后的保障。
    try {
      if (useCloud) {
        // 延迟一点点，让本地 IndexedDB 先落盘变更日志
        setTimeout(() => syncLoop(), 500);
      }
    } catch (e) {
      console.warn('[LinkController] Trigger syncLoop failed:', e);
    }

    return updated;
  },

  /**
   * Delete a link
   * @param {number|string} id 
   */
  async deleteLink(id) {
    const links = await storageAdapter.getLinks();
    const data = links.find(c => String(c.id) === String(id));
    
    const silent = !!this._view;
    await storageAdapter.deleteLink(id, { silent });

    if (this._view) {
        this._view.removeSingleCardUI(id);
    }

    // 中文注释：删除云端数据（SDK 优先，失败或缺少 userId 时回退 EdgeFn）
    if (useCloud && supabase && data) {
        // 中文注释：优先从 Supabase Session 获取真实 UUID，若无则尝试 storageAdapter
        let userId = (await supabase.auth.getSession())?.data?.session?.user?.id;
        if (!userId) userId = storageAdapter.getUser()?.id || null;
        
        // 尝试获取云端 ID（Server ID）
        // 如果 data.id 是 UUID 格式，则直接使用；否则尝试从映射中查找，或回退到 URL 匹配
        // 但用户强调“生成卡片都会出现 id 的”，所以这里的 data.id 应该是可信的 UUID
        // 为了保险，我们假设如果 id 包含 '-' 且长度 > 20，则为 UUID
        let serverId = String(data.id);
        const isUUID = serverId.includes('-') && serverId.length > 20;
        // 中文注释：统一 URL 为绝对地址以确保与云端匹配
        const absUrl = data.url ? ensureAbsoluteUrl(data.url) : '';
        
        let sdkOk = false;
        if (userId) {
          try {
            // 中文注释：删除后通过 select('id') 返回受影响行；若为 0 则触发回退
            let query = supabase.from('links').delete().eq('user_id', userId);
            
            // 优先使用 ID 删除
            if (isUUID) {
                query = query.eq('id', serverId);
            } else if (absUrl) {
                query = query.eq('url', absUrl);
            } else {
                throw new Error('No valid ID or URL for deletion');
            }

            const { data: delData, error } = await query.select('id');
            if (error) throw error;
            sdkOk = Array.isArray(delData) && delData.length > 0;
            if (sdkOk) {
              logger.info('[LinkController] 云端删除成功（SDK）');
            } else {
              logger.warn(`[Supabase] SDK 删除成功但无匹配行 (id=${serverId})，准备回退 EdgeFn`);
            }
          } catch (err) {
            logger.warn('[Supabase] SDK 删除失败，准备回退 EdgeFn', err?.message || err);
          }
        }
        if (!sdkOk) {
          try {
            // 优先传 ID 给 Edge Function
            const payload = isUUID ? { id: serverId } : { url: absUrl };
            logger.info('[EdgeFn] delete-link 请求', { payload });
            const resp = await callFunction('delete-link', { method: 'POST', body: JSON.stringify(payload) });
            if (!resp.ok) {
              const j = await resp.json().catch(()=>({}));
              throw new Error(j.error || `HTTP_${resp.status}`);
            }
            logger.info('[LinkController] EdgeFn:delete-link 删除成功');
          } catch (e) {
            logger.warn('[LinkController] EdgeFn:delete-link 删除失败', e?.message || e);
          }
        }
    }
  },

  /**
   * Initialize with sample data
   */
  async injectSamples() {
      const samples = [
        {
          title: 'Figma — Design tool',
          description: 'AI Summary: Figma is a modern design collaboration platform for prototyping and UI design.',
          category: 'Design',
          tags: ['Design', 'Productivity'],
          url: 'https://figma.com/',
        },
        {
          title: 'OpenAI — GPT Models',
          description: 'AI Summary: OpenAI provides advanced large language models and API access.',
          category: 'AI',
          tags: ['AI', 'Research'],
          url: 'https://openai.com/',
        },
        {
          title: 'GitHub — Code hosting',
          description: 'AI Summary: GitHub is a mainstream code hosting and collaboration platform.',
          category: 'Development',
          tags: ['Development'],
          url: 'https://github.com/',
        },
      ];
      for (const data of samples) {
          await storageAdapter.addLink(data);
      }
  },

  // Category Management
  getCategories() {
      return storageAdapter.getCategories();
  },

  ensureCategory(name) {
      return storageAdapter.ensureCategory(name);
  },

  async deleteCategory(name) {
      storageAdapter.deleteCategory(name);
      // Update links
      const links = await storageAdapter.getLinks();
      let changed = false;
      links.forEach(l => {
        if (l.category === name) {
            l.category = 'All Links';
            changed = true;
        }
      });
      if (changed) storageAdapter.saveLinks(links);
  },

  /**
   * 将现有链接随机分配到分类（开发辅助）
   * - 若当前仅存在 'All Links'，会自动创建一组默认分类
   * - 排除保留分类 'All Links'
   * @param {Array<string>} pool 自定义分类池（可选）
   * @returns {Promise<number>} 实际更新的链接数量
   */
  async distributeToCategories(pool = []) {
    const isDev = import.meta?.env?.DEV;
    if (!isDev) return 0; // 中文注释：仅开发环境允许批量分配

    // 中文注释：读取现有分类；若不足，则创建默认分类集
    let cats = Array.isArray(pool) && pool.length ? pool.slice() : (await storageAdapter.getCategories());
    const RESERVED = new Set(['All Links']);
    if (!cats || cats.filter(c => !RESERVED.has(c)).length === 0) {
      cats = ['AI','Design','News','Dev','Tools','Product','Blog','Research','Docs'];
      for (const c of cats) { try { await storageAdapter.ensureCategory(c); } catch {} }
    }
    const choices = cats.filter(c => !RESERVED.has(c));
    if (choices.length === 0) return 0;

    // 中文注释：读取所有链接并随机分配分类；为减少通知风暴，使用 silent 写入并在视图存在时局部刷新
    const links = await storageAdapter.getLinks();
    const silent = !!this._view;
    let updated = 0;

    const pick = () => choices[Math.floor(Math.random() * choices.length)];
    for (const l of links) {
      const target = pick();
      if (!target || l.category === target) continue;
      await storageAdapter.updateLink(l.id, { category: target }, { silent });
      if (this._view) {
        try { this._view.updateSingleCardUI(l.id, { category: target }); } catch {}
      }
      updated++;
    }

    // 中文注释：更新侧栏（视图存在时会在 updateSingleCardUI 内自动刷新；此处兜底）
    try { await storageAdapter.notify({ type: 'links_changed' }); } catch {}

    return updated;
  },

  /**
   * 批量生成随机链接（仅开发模式）
   * @param {number} count 生成数量，默认 200
   * @returns {Promise<number>} 实际生成数量
   */
  async seedRandomLinks(count = 200) {
    // 中文注释：仅在开发模式允许批量生成，避免污染生产数据
    const isDev = import.meta?.env?.DEV;
    if (!isDev) return 0;
    const safeCount = Math.max(1, Math.min(1000, Number(count) || 200));

    // 中文注释：准备随机词库与辅助函数
    const words = ['alpha','beta','gamma','delta','omega','nova','pixel','orbit','quantum','rune','matrix','vector','flux','zen','nimbus','spark'];
    const pick = () => words[Math.floor(Math.random() * words.length)];
    const rand = (n=999999) => Math.floor(Math.random() * n) + 1;

    // 中文注释：静默写入以提升性能（视图存在时走局部插入）
    const silent = !!this._view;
    let created = 0;

    for (let i = 0; i < safeCount; i++) {
      const dn = `${pick()}-${rand(9999)}`;
      const path = `${pick()}/${rand(999)}`;
      const url = `https://www.${dn}.example.com/${path}`;

      // 中文注释：去重检查（避免重复 URL 导致报错）
      const exists = await this.findLinkByUrl(url);
      if (exists) continue;

      const data = {
        title: `Random Site ${i + 1} · ${pick()}`,
        description: '随机占位描述（开发数据），可用于分页与筛选性能测试。',
        category: 'All Links',
        tags: ['bookmark','random'],
        url
      };

      const added = await storageAdapter.addLink(data, { silent });
      // 中文注释：若视图存在，执行局部 UI 插入以避免全量重渲染
      if (this._view) {
        try { this._view.addSingleCardUI(added); } catch(e) {}
      }
      created++;
    }

    // 中文注释：确保分类侧栏包含 All Links（通常默认存在）
    try { storageAdapter.ensureCategory('All Links'); } catch {}

    return created;
  },

  /**
   * 登录后初始化同步与迁移（可由外部在登录成功后调用）
   */
  async initSyncAfterLogin() {
    try {
      await migrateLocalToCloud();
      syncLoop();
    } catch (e) {
      console.warn('[InitSync] failed', e);
    }
  }
};
