import storageAdapter from "../storage/storageAdapter.js";
import { normalizeUrl } from "../utils/url.js";
import { mockAIFromUrl as mockAIFromUrlExternal } from "../../mockFunctions.js";

// Cloud Configuration
const SUPABASE_URL = (import.meta?.env?.VITE_SUPABASE_URL || '').trim();
const SUPABASE_ANON_KEY = (import.meta?.env?.VITE_SUPABASE_ANON_KEY || '').trim();
const useCloud = Boolean(SUPABASE_URL && SUPABASE_ANON_KEY);

/**
 * Fetch link metadata from Cloud Edge Function
 * @param {string} url 
 * @returns {Promise<object>}
 */
async function fetchAIFromCloud(url) {
  if (!useCloud) throw new Error('Cloud not configured');
  const endpoint = `${SUPABASE_URL}/functions/v1/super-endpoint`;
  const res = await fetch(endpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
    },
    body: JSON.stringify({ url })
  });
  if (!res.ok) throw new Error(`Cloud AI failed: ${res.status}`);
  return await res.json();
}

/**
 * Load links from Cloud Supabase
 * @returns {Promise<Array>}
 */
async function loadCloudLinks() {
  if (!useCloud) return [];
  try {
    const endpoint = `${SUPABASE_URL}/rest/v1/links?select=*`;
    const res = await fetch(endpoint, {
      headers: {
        'apikey': SUPABASE_ANON_KEY,
        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
      }
    });
    if (!res.ok) throw new Error(`List failed: ${res.status}`);
    const arr = await res.json();
    return (Array.isArray(arr) ? arr : []).map(row => ({
      id: row.id, // Use ID from cloud
      url: row.url || '',
      title: row.title || 'Untitled',
      description: row.description || 'Summary from cloud',
      category: row.category || 'All Links',
      tags: Array.isArray(row.tags) ? row.tags : [],
      created_at: row.created_at || Date.now(),
      updated_at: row.updated_at || Date.now(),
    }));
  } catch (e) {
    console.warn('Load cloud links failed:', e);
    return [];
  }
}

// =============================
// Link Controller Logic
// =============================

export const linkController = {
  /**
   * Get all links with subscription status
   * @returns {Promise<Array>} Links array with 'subscribed' boolean
   */
  async getLinks() {
    // 1. Read Links
    let links = await storageAdapter.getLinks();
    
    // Check empty / cloud logic
    if (links.length === 0 && useCloud) {
       const cloudLinks = await loadCloudLinks();
       if (cloudLinks.length > 0) {
          // Sync cloud links to local
          for (const c of cloudLinks) {
             const exists = links.find(l => normalizeUrl(l.url) === normalizeUrl(c.url));
             if (!exists) {
               await storageAdapter.addLink(c);
             }
             storageAdapter.ensureCategory(c.category);
          }
          // Refetch to get IDs generated by adapter if any (though adapter usually returns object)
          links = await storageAdapter.getLinks();
       } else {
         // No cloud links, inject samples if truly empty
         // This logic was in dashboard.js "injectSamples".
         // We'll expose injectSamples as a separate method or handle it here?
         // The dashboard logic was: if empty -> try cloud -> if cloud empty -> inject samples.
         // We will return empty list here and let dashboard decide to inject samples?
         // Or we provide an "initializeDefaults" method.
       }
    }

    // 2. Read Subscriptions
    const subs = await storageAdapter.getSubscriptions();
    
    // 3. Merge Subscription Status
    const subMap = new Map(subs.filter(s => s.enabled !== false).map(s => [String(s.linkId), s.id]));
    
    return links.map(link => ({
        ...link,
        subscribed: subMap.has(String(link.id)),
        subscriptionId: subMap.get(String(link.id)) || null
    }));
  },

  /**
   * Subscribe to a link
   * @param {number|string} linkId 
   */
  async subscribe(linkId) {
    return await storageAdapter.subscribeToLink(linkId);
  },

  /**
   * Unsubscribe from a link
   * @param {number|string} subId 
   */
  async unsubscribe(subId) {
    // storageAdapter might not have unsubscribeById, it has deleteSubscription(id) or similar?
    // storageAdapter has `updateSubscription` (enable/disable) or delete.
    // Usually we toggle `enabled`.
    // Let's check storageAdapter.
    const subs = await storageAdapter.getSubscriptions();
    const sub = subs.find(s => String(s.id) === String(subId));
    if (sub) {
        sub.enabled = false; // Soft delete/disable
        await storageAdapter.updateSubscription(sub);
    }
  },

  /**
   * Get all subscriptions (for UI updates)
   * @returns {Promise<Array>}
   */
  async getSubscriptions() {
    return await storageAdapter.getSubscriptions();
  },

  /**
   * Find a link by URL
   * @param {string} url 
   * @returns {Promise<object|null>}
   */
  async findLinkByUrl(url) {
    const target = String(url).trim();
    if (!target) return null;
    const links = await storageAdapter.getLinks();
    return links.find(c => String(c.url).trim() === target) || null;
  },

  /**
   * Add a new link
   * @param {string} rawUrl 
   * @returns {Promise<object>} The created link object
   */
  async addLink(rawUrl) {
    const normalized = normalizeUrl(rawUrl);
    if (!normalized) throw new Error('Invalid URL');

    // Check duplicate
    const exists = await this.findLinkByUrl(normalized);
    if (exists) throw new Error('Link already exists');

    // Fetch Metadata (Cloud or Mock)
    let ai = null;
    if (useCloud) {
      try { ai = await fetchAIFromCloud(normalized); } catch { ai = null; }
    }
    const mock = ai || await mockAIFromUrlExternal(normalized).catch(() => ({ 
        title: '', description: '', category: 'All Links', tags: ['bookmark'] 
    }));

    const data = {
      title: mock?.title || (normalized.replace(/^https?:\/\//, '').split('/')[0] || 'Untitled'),
      description: mock?.description || 'Mock: Auto-generated summary placeholder.',
      category: mock?.category || 'All Links',
      tags: Array.isArray(mock?.tags) && mock.tags.length ? mock.tags : ['bookmark'],
      url: normalized,
    };

    const added = await storageAdapter.addLink(data);
    return added;
  },

  /**
   * Update an existing link
   * @param {number|string} id 
   * @param {object} updates { title, url, description, tags, category }
   * @returns {Promise<object>} Updated link object
   */
  async updateLink(id, updates) {
    const { title, url, description, tags, category } = updates;
    
    // Check URL conflict if URL changed
    if (url) {
        const normalized = normalizeUrl(url);
        const allLinks = await storageAdapter.getLinks();
        const conflict = allLinks.find(c => String(c.id) !== String(id) && normalizeUrl(c.url) === normalized);
        if (conflict) {
            throw new Error(`URL conflict: "${conflict.title}" already uses this URL.`);
        }
    }

    await storageAdapter.updateLink(id, { title, url, description, tags, category });

    // Sync to Cloud (Fire and Forget or Await?)
    // Dashboard code awaited it but caught errors.
    if (useCloud && url) {
        try {
            const endpoint = `${SUPABASE_URL}/functions/v1/update-link`;
            await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${SUPABASE_ANON_KEY}` },
            body: JSON.stringify({ url, title, description, category, tags })
            });
        } catch (err) {
            console.error('Cloud update failed:', err);
        }
    }

    const updated = (await storageAdapter.getLinks()).find(c => String(c.id) === String(id));
    if (!updated) throw new Error('Link not found after update');
    return updated;
  },

  /**
   * Delete a link
   * @param {number|string} id 
   */
  async deleteLink(id) {
    const links = await storageAdapter.getLinks();
    const data = links.find(c => String(c.id) === String(id));
    
    await storageAdapter.deleteLink(id);

    if (useCloud && data?.url) {
        try {
            const endpoint = `${SUPABASE_URL}/functions/v1/delete-link`;
            await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${SUPABASE_ANON_KEY}` },
            body: JSON.stringify({ url: data.url })
            });
        } catch (err) {
            console.error('Cloud delete failed:', err);
        }
    }
  },

  /**
   * Initialize with sample data
   */
  async injectSamples() {
      const samples = [
        {
          title: 'Figma — Design tool',
          description: 'AI Summary: Figma is a modern design collaboration platform for prototyping and UI design.',
          category: 'Design',
          tags: ['Design', 'Productivity'],
          url: 'https://figma.com/',
        },
        {
          title: 'OpenAI — GPT Models',
          description: 'AI Summary: OpenAI provides advanced large language models and API access.',
          category: 'AI',
          tags: ['AI', 'Research'],
          url: 'https://openai.com/',
        },
        {
          title: 'GitHub — Code hosting',
          description: 'AI Summary: GitHub is a mainstream code hosting and collaboration platform.',
          category: 'Development',
          tags: ['Development'],
          url: 'https://github.com/',
        },
      ];
      for (const data of samples) {
          await storageAdapter.addLink(data);
      }
  },

  // Category Management
  getCategories() {
      return storageAdapter.getCategories();
  },

  ensureCategory(name) {
      return storageAdapter.ensureCategory(name);
  },

  async deleteCategory(name) {
      storageAdapter.deleteCategory(name);
      // Update links
      const links = await storageAdapter.getLinks();
      let changed = false;
      links.forEach(l => {
        if (l.category === name) {
            l.category = 'All Links';
            changed = true;
        }
      });
      if (changed) storageAdapter.saveLinks(links);
  }
};
