import storageAdapter from "../storage/storageAdapter.js";
import { normalizeUrl } from "../utils/url.js";
import { mockAIFromUrl as mockAIFromUrlExternal } from "../../mockFunctions.js";
import { migrateLocalToCloud } from "../sync/migrate.js";
import { syncLoop } from "../sync/syncAgent.js";
import { supabase } from "../services/supabaseClient.js";

// Cloud Configuration
const SUPABASE_URL = (import.meta?.env?.VITE_SUPABASE_URL || '').trim();
const SUPABASE_ANON_KEY = (import.meta?.env?.VITE_SUPABASE_ANON_KEY || '').trim();
const useCloud = Boolean(SUPABASE_URL && SUPABASE_ANON_KEY);

/**
 * Fetch link metadata from Cloud Edge Function
 * @param {string} url 
 * @returns {Promise<object>}
 */
async function fetchAIFromCloud(url) {
  // 中文注释：使用 Supabase SDK 调用 Edge Function（替代手动 fetch）
  if (!useCloud || !supabase) throw new Error('Cloud not configured');
  const { data, error } = await supabase.functions.invoke('super-endpoint', {
    body: { url },
  });
  if (error) throw error;
  return data;
}

/**
 * Load links from Cloud Supabase
 * @returns {Promise<Array>}
 */
async function loadCloudLinks() {
  // 中文注释：使用 Supabase SDK 拉取云端 links 列表，替代手动 fetch
  if (!useCloud || !supabase) return [];
  try {
    const { data, error } = await supabase
      .from('links')
      .select('*');
    if (error) throw error;
    const arr = Array.isArray(data) ? data : [];
    return arr.map(row => ({
      id: row.id,
      url: row.url || '',
      title: row.title || 'Untitled',
      description: row.description || 'Summary from cloud',
      category: row.category || 'All Links',
      tags: Array.isArray(row.tags) ? row.tags : [],
      created_at: row.created_at || Date.now(),
      updated_at: row.updated_at || Date.now(),
    }));
  } catch (e) {
    console.warn('[Supabase] loadCloudLinks failed:', e);
    return [];
  }
}

// =============================
// Link Controller Logic
// =============================

export const linkController = {
  _view: null,
  
  // Pagination State
  _pagination: {
    currentPage: 0,
    isLoading: false,
    hasMore: true
  },

  /**
   * Set the view for partial updates
   * @param {object} view 
   */
  setView(view) {
    this._view = view;
  },

  /**
   * Get all links with subscription status
   * @returns {Promise<Array>} Links array with 'subscribed' boolean
   */
  async getLinks() {
    // 1. Read Links
    let links = await storageAdapter.getLinks();
    
    // Check empty / cloud logic
    if (links.length === 0 && useCloud) {
       const cloudLinks = await loadCloudLinks();
       if (cloudLinks.length > 0) {
          // Sync cloud links to local
          for (const c of cloudLinks) {
             const exists = links.find(l => normalizeUrl(l.url) === normalizeUrl(c.url));
             if (!exists) {
               await storageAdapter.addLink(c);
             }
             storageAdapter.ensureCategory(c.category);
          }
          // Refetch to get IDs generated by adapter if any (though adapter usually returns object)
          links = await storageAdapter.getLinks();
       } else {
         // No cloud links, inject samples if truly empty
         // This logic was in dashboard.js "injectSamples".
         // We'll expose injectSamples as a separate method or handle it here?
         // The dashboard logic was: if empty -> try cloud -> if cloud empty -> inject samples.
         // We will return empty list here and let dashboard decide to inject samples?
         // Or we provide an "initializeDefaults" method.
       }
    }

    // 2. Read Subscriptions
    const subs = await storageAdapter.getSubscriptions();
    
    // 3. Merge Subscription Status
    const subMap = new Map(subs.filter(s => s.enabled !== false).map(s => [String(s.linkId), s.id]));
    
    return links.map(link => ({
        ...link,
        subscribed: subMap.has(String(link.id)),
        subscriptionId: subMap.get(String(link.id)) || null
    }));
  },

  /**
   * Subscribe to a link
   * @param {number|string} linkId 
   */
  async subscribe(linkId) {
    const silent = !!this._view;
    const sub = await storageAdapter.subscribeToLink(linkId, { silent });
    if (this._view) {
        this._view.updateSingleCardUI(linkId, { subscribed: true, subscriptionId: sub.id });
    }
    return sub;
  },

  /**
   * Unsubscribe from a link
   * @param {number|string} subId 
   */
  async unsubscribe(subId) {
    // storageAdapter might not have unsubscribeById, it has deleteSubscription(id) or similar?
    // storageAdapter has `updateSubscription` (enable/disable) or delete.
    // Usually we toggle `enabled`.
    // Let's check storageAdapter.
    const subs = await storageAdapter.getSubscriptions();
    const sub = subs.find(s => String(s.id) === String(subId));
    if (sub) {
        sub.enabled = false; // Soft delete/disable
        const silent = !!this._view;
        await storageAdapter.updateSubscription(sub, { silent });
        if (this._view) {
             this._view.updateSingleCardUI(sub.linkId, { subscribed: false });
        }
    }
  },

  /**
   * Fetch paginated links
   * @param {number} pageIndex 0-based index
   * @param {number} pageSize 
   * @returns {Promise<object>} { items, total, hasMore }
   */
  async fetchPage(pageIndex = 0, pageSize = 20) {
    // Sync state if page 0 is requested (reset)
    if (pageIndex === 0) {
        this._pagination.currentPage = 0;
        this._pagination.hasMore = true;
        this._pagination.isLoading = false;
    }

    const offset = pageIndex * pageSize;
    return await storageAdapter.getLinksPage({ limit: pageSize, offset });
  },

  async loadNextPage() {
    if (this._pagination.isLoading || !this._pagination.hasMore) return;
    
    this._pagination.isLoading = true;
    try {
        const nextPage = this._pagination.currentPage + 1;
        const { items, total, hasMore } = await this.fetchPage(nextPage, 20);
        
        // Update state
        this._pagination.currentPage = nextPage;
        this._pagination.hasMore = hasMore;
        
        // Append to view
        if (items.length > 0 && this._view) {
            this._view.appendPage(items);
        }
    } catch (err) {
        console.error('Failed to load next page:', err);
    } finally {
        this._pagination.isLoading = false;
    }
  },

  /**
   * Get all subscriptions (for UI updates)
   * @returns {Promise<Array>}
   */
  async getSubscriptions() {
    return await storageAdapter.getSubscriptions();
  },

  /**
   * Find a link by URL
   * @param {string} url 
   * @returns {Promise<object|null>}
   */
  async findLinkByUrl(url) {
    const target = String(url).trim();
    if (!target) return null;
    const links = await storageAdapter.getLinks();
    return links.find(c => String(c.url).trim() === target) || null;
  },

  /**
   * Add a new link
   * @param {string} rawUrl 
   * @returns {Promise<object>} The created link object
   */
  async addLink(rawUrl) {
    const normalized = normalizeUrl(rawUrl);
    if (!normalized) throw new Error('Invalid URL');

    // Check duplicate
    const exists = await this.findLinkByUrl(normalized);
    if (exists) throw new Error('Link already exists');

    // Fetch Metadata (Cloud or Mock)
    let ai = null;
    if (useCloud) {
      try { ai = await fetchAIFromCloud(normalized); } catch { ai = null; }
    }
    const mock = ai || await mockAIFromUrlExternal(normalized).catch(() => ({ 
        title: '', description: '', category: 'All Links', tags: ['bookmark'] 
    }));

    const data = {
      title: mock?.title || (normalized.replace(/^https?:\/\//, '').split('/')[0] || 'Untitled'),
      description: mock?.description || 'Mock: Auto-generated summary placeholder.',
      category: mock?.category || 'All Links',
      tags: Array.isArray(mock?.tags) && mock.tags.length ? mock.tags : ['bookmark'],
      url: normalized,
    };

    const silent = !!this._view;
    const added = await storageAdapter.addLink(data, { silent });
    if (this._view) {
        this._view.addSingleCardUI(added);
    }
    return added;
  },

  /**
   * Update an existing link
   * @param {number|string} id 
   * @param {object} updates { title, url, description, tags, category }
   * @returns {Promise<object>} Updated link object
   */
  async updateLink(id, updates) {
    const { title, url, description, tags, category } = updates;
    
    // Check URL conflict if URL changed
    if (url) {
        const normalized = normalizeUrl(url);
        const allLinks = await storageAdapter.getLinks();
        const conflict = allLinks.find(c => String(c.id) !== String(id) && normalizeUrl(c.url) === normalized);
        if (conflict) {
            throw new Error(`URL conflict: "${conflict.title}" already uses this URL.`);
        }
    }

    const silent = !!this._view;
    await storageAdapter.updateLink(id, { title, url, description, tags, category }, { silent });

    // 中文注释：使用 Supabase SDK 更新云端数据（替代 Edge Function）
    if (useCloud && supabase && url) {
        try {
            const updates = { title, description, category, tags };
            const { error } = await supabase
              .from('links')
              .update(updates)
              .eq('url', url);
            if (error) throw error;
        } catch (err) {
            console.error('[Supabase] update link failed:', err);
        }
    }

    const updated = (await storageAdapter.getLinks()).find(c => String(c.id) === String(id));
    if (!updated) throw new Error('Link not found after update');
    
    if (this._view) {
        this._view.updateSingleCardUI(id, updated);
    }

    return updated;
  },

  /**
   * Delete a link
   * @param {number|string} id 
   */
  async deleteLink(id) {
    const links = await storageAdapter.getLinks();
    const data = links.find(c => String(c.id) === String(id));
    
    const silent = !!this._view;
    await storageAdapter.deleteLink(id, { silent });

    if (this._view) {
        this._view.removeSingleCardUI(id);
    }

    // 中文注释：使用 Supabase SDK 删除云端数据（替代 Edge Function）
    if (useCloud && supabase && data?.url) {
        try {
            const { error } = await supabase
              .from('links')
              .delete()
              .eq('url', data.url);
            if (error) throw error;
        } catch (err) {
            console.error('[Supabase] delete link failed:', err);
        }
    }
  },

  /**
   * Initialize with sample data
   */
  async injectSamples() {
      const samples = [
        {
          title: 'Figma — Design tool',
          description: 'AI Summary: Figma is a modern design collaboration platform for prototyping and UI design.',
          category: 'Design',
          tags: ['Design', 'Productivity'],
          url: 'https://figma.com/',
        },
        {
          title: 'OpenAI — GPT Models',
          description: 'AI Summary: OpenAI provides advanced large language models and API access.',
          category: 'AI',
          tags: ['AI', 'Research'],
          url: 'https://openai.com/',
        },
        {
          title: 'GitHub — Code hosting',
          description: 'AI Summary: GitHub is a mainstream code hosting and collaboration platform.',
          category: 'Development',
          tags: ['Development'],
          url: 'https://github.com/',
        },
      ];
      for (const data of samples) {
          await storageAdapter.addLink(data);
      }
  },

  // Category Management
  getCategories() {
      return storageAdapter.getCategories();
  },

  ensureCategory(name) {
      return storageAdapter.ensureCategory(name);
  },

  async deleteCategory(name) {
      storageAdapter.deleteCategory(name);
      // Update links
      const links = await storageAdapter.getLinks();
      let changed = false;
      links.forEach(l => {
        if (l.category === name) {
            l.category = 'All Links';
            changed = true;
        }
      });
      if (changed) storageAdapter.saveLinks(links);
  },

  /**
   * 登录后初始化同步与迁移（可由外部在登录成功后调用）
   */
  async initSyncAfterLogin() {
    try {
      await migrateLocalToCloud();
      syncLoop();
    } catch (e) {
      console.warn('[InitSync] failed', e);
    }
  }
};
